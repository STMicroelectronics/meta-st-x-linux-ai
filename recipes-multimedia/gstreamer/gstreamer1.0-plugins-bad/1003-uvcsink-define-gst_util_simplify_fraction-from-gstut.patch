From 12c97fc28253ed804dd5661dd7235f1ad7ff0bb2 Mon Sep 17 00:00:00 2001
From: Vincent ABRIOU <vincent.abriou@st.com>
Date: Wed, 2 Apr 2025 14:07:50 +0200
Subject: [PATCH 3/4] uvcsink:define gst_util_simplify_fraction from gstutils.c
 1.24.6

Upstream-Status: Inappropriate [backport gst_util function for uvcsink]

Signed-off-by: Vincent ABRIOU <vincent.abriou@st.com>
---
 sys/uvcgadget/gstuvcsink.c | 69 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 69 insertions(+)

diff --git a/sys/uvcgadget/gstuvcsink.c b/sys/uvcgadget/gstuvcsink.c
index 395cf2a..c052682 100644
--- a/sys/uvcgadget/gstuvcsink.c
+++ b/sys/uvcgadget/gstuvcsink.c
@@ -79,6 +79,75 @@ static GstStateChangeReturn gst_uvc_sink_change_state (GstElement *
 static void gst_uvc_sink_dispose (GObject * object);
 static gboolean gst_uvc_sink_prepare_configfs (GstUvcSink * self);
 
+/* Patch: define gst_util_simplify_fraction from gstutils.c 1.24.6 */
+/**
+ * gst_util_simplify_fraction:
+ * @numerator: First value as #gint
+ * @denominator: Second value as #gint
+ * @n_terms: non-significative terms (typical value: 8)
+ * @threshold: threshold (typical value: 333)
+ *
+ * Calculates the simpler representation of @numerator and @denominator and
+ * update both values with the resulting simplified fraction.
+ *
+ * Simplify a fraction using a simple continued fraction decomposition.
+ * The idea here is to convert fractions such as 333333/10000000 to 1/30
+ * using 32 bit arithmetic only. The algorithm is not perfect and relies
+ * upon two arbitrary parameters to remove non-significative terms from
+ * the simple continued fraction decomposition. Using 8 and 333 for
+ * @n_terms and @threshold respectively seems to give nice results.
+ *
+ * Since: 1.24
+ */
+void
+gst_util_simplify_fraction (gint * numerator, gint * denominator,
+    guint n_terms, guint threshold)
+{
+  guint *an;
+  guint x, y, r;
+  guint i, n;
+
+  an = g_malloc_n (n_terms, sizeof (*an));
+  if (an == NULL)
+    return;
+
+  /*
+   * Convert the fraction to a simple continued fraction. See
+   * https://en.wikipedia.org/wiki/Continued_fraction
+   * Stop if the current term is bigger than or equal to the given
+   * threshold.
+   */
+  x = *numerator;
+  y = *denominator;
+
+  for (n = 0; n < n_terms && y != 0; ++n) {
+    an[n] = x / y;
+    if (an[n] >= threshold) {
+      if (n < 2)
+        n++;
+      break;
+    }
+
+    r = x - an[n] * y;
+    x = y;
+    y = r;
+  }
+
+  /* Expand the simple continued fraction back to an integer fraction. */
+  x = 0;
+  y = 1;
+
+  for (i = n; i > 0; --i) {
+    r = y;
+    y = an[i - 1] * y + x;
+    x = r;
+  }
+
+  *numerator = y;
+  *denominator = x;
+  g_free (an);
+}
+
 static void
 gst_uvc_sink_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec)
-- 
2.25.1

